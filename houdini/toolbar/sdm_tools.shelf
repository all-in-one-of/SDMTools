<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="com.sashaouellet::sdm_tools" label="SDM Tools">
    <memberTool name="com.sashaouellet::SavePrefsToStuhome"/>
    <memberTool name="com.sashaouellet::MultiFlipbook"/>
    <memberTool name="com.sashaouellet::CleanSubnet"/>
    <memberTool name="com.sashaouellet::CalculateMocapLocomotion"/>
    <memberTool name="com.sashaouellet::convertrat::1.0"/>
  </toolshelf>

  <tool name="com.sashaouellet::MultiFlipbook" label="Multi Flipbook" icon="hicon:/SVGIcons.index?BUTTONS_capture.svg">
    <helpText><![CDATA[= Multi Flipbook =

"""Allows for flipbooking from multiple cameras simultaneously"""

Select all the cameras you want to flipbook from as well as the frame range and frame increment for the flipbook. Then select the file location to save to, making sure to include the $F syntax (or $F3, etc). The viewport will then be exported to these files with the camera name prefixed to the chosen file name.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os

cameras = [c for c in hou.node('/').allSubChildren() if c.type().name() == 'cam']
selected = [cameras[i] for i in hou.ui.selectFromList([c.name() for c in cameras], message='Select the camera(s) to flipbook from', title='Camera Selection', column_header='Cameras')]
outputBase = hou.ui.selectFile(title='Save Sequence(s) as...', collapse_sequences=True, file_type=hou.fileType.Image, chooser_mode=hou.fileChooserMode.Write)

if not outputBase or '$F' not in outputBase:
    hou.ui.displayMessage('Invalid output path specified (Make sure to use $F, $F4, etc. notation)', severity=hou.severityType.Error)
    raise SystemExit

splitBase = os.path.split(outputBase)
sceneViewer = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)

frameStart = int(sceneViewer.flipbookSettings().frameRange()[0])
frameEnd = int(sceneViewer.flipbookSettings().frameRange()[1])
frameInc = sceneViewer.flipbookSettings().frameIncrement()

frameInput = hou.ui.readMultiInput('Select frame range for flipbook(s)', ['Start', 'End', 'Inc'], initial_contents=[str(frameStart), str(frameEnd), str(frameInc)])

frameStart = int(frameInput[1][0])
frameEnd = int(frameInput[1][1])
frameInc = int(frameInput[1][2])

if not sceneViewer:
    hou.ui.displayMessage('Could not find Scene Viewer pane tab, please create it and try again', severity=hou.severityType.Error)
    raise SystemExit
    
viewport = [vp for vp in sceneViewer.viewports() if vp.type() == hou.geometryViewportType.Perspective][0]

if not viewport:
    hou.ui.displayMessage('Could not find the "Persp" viewport', severity=hou.severityType.Error)
    raise SystemExit
    
viewportFullName = '{}.{}.world.{}'.format(hou.ui.curDesktop().name(), sceneViewer.name(), viewport.name())
cameraOutputs = []

for camera in selected:
    cameraOutputs.append((camera, os.path.join(splitBase[0], '{}_{}'.format(camera.name(), splitBase[1]))))

for f in range(frameStart, frameEnd + 1, frameInc):
    for camera, output in cameraOutputs:
        hou.setFrame(f)
        viewport.setCamera(camera)
        
        hou.hscript("viewwrite -f {} {} {} '{}'".format(f, f, viewportFullName, output))]]></script>
  </tool>

  <tool name="com.sashaouellet::SavePrefsToStuhome" label="Save Prefs to Stuhome" icon="hicon:/SVGIcons.index?VOP_subnetconnector.svg">
    <helpText><![CDATA[= Save Prefs to Stuhome =

"""Saves desktops and other preferences on the network"""

This tool is meant to work alongside a bash_custom that copies your houdini16.0 folder from ~/mount/stuhome to ~/.

Example bash_custom:

rm -rf ~/houdini16.0

cp -r ~/mount/stuhome/houdini16.0 ~/houdini16.0

WARNING:
    Do not use this tool on Windows as it will crash Houdini. Your Houdini preferences are already synced on the network anyway on Windows.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os

def main():
    if not os.path.exists('~/mount/stuhome/houdini16.0'):
        return
    
    os.system('rm -rf ~/mount/stuhome/houdini16.0')
    os.system('cp -r ~/houdini16.0 ~/mount/stuhome/houdini16.0')
    
    hou.ui.displayMessage('Successfully copied preferences')

main()]]></script>
  </tool>

  <tool name="com.sashaouellet::CleanSubnet" label="Clean Subnet" icon="hicon:/SVGIcons.index?BUTTONS_clear.svg">
    <helpText><![CDATA[= Clean Subnet =

"""Removes the entire tree structure from selected nodes of a subnet"""

This is a convienence tool for cleaning up large FBX's. Note that the selection is the node trees you want to delete.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[def main():
    selected = hou.selectedNodes()
    
    if selected and len(selected) == 1:
        subnet = selected[0] # Selected subnet
        topLevel = [c for c in subnet.children() if not c.inputConnections()] # All nodes inside the subnet with no incoming connections are assumed to be top level parents
        potentialDelete = ['System', 'Unlabeled_Markers'] # Node names for nodes that we probably will always delete
        bestGuesses = [topLevel.index(n) for n in topLevel if n.name() in potentialDelete] # We guess from the children nodes based on potentialDelete
        
        # bestGuesses is passed as the default choices, which will highlight them automatically and queue for deletion
        # We clear this selection on cancel, so that they don't accidentally delete anything
        toDelete = [topLevel[i] for i in hou.ui.selectFromList([n.name() for n in topLevel], default_choices=bestGuesses, message='Select top level parents that you want to DELETE', title='Delete Trees')]
        
        if toDelete and hou.ui.displayConfirmation('You are about to delete: {} and all of the connections to these nodes. Are you sure you want to proceed?'.format(', '.join([n.name() for n in toDelete]))):
            for node in toDelete:
                deleteTree(node)
        
        subnet.layoutChildren()
    else:
        hou.ui.displayMessage('Please select a single node for cleanup', severity=hou.severityType.Error)
        return

        
def deleteTree(node):
    if not node.isLockedHDA() and not node.isInsideLockedHDA():
        for connected in [n.outputNode() for n in node.outputConnections()]:
            deleteTree(connected) # Recursively delete output connections
        node.destroy()
main()]]></script>
  </tool>

  <tool name="com.sashaouellet::CalculateMocapLocomotion" label="Calculate Mocap Locomotion" icon="hicon:/SVGIcons.index?OBJ_simplemale.svg">
    <helpText><![CDATA[= Calculate Mocap Locomotion =

"""Applies physical transforms to mocap rig based on stride length/speed."""

This tool will automatically calculate a stride length from the frame range that is selected and the 2 bones selected. It is recommended you choose the feet bones, and the tool will automatically pick those for you to begin with. The transform is applied to the root of the mocap rig.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import sys, math
from numpy.linalg import norm
from numpy import array

FRAME_TIMEOUT = 5

def main():
    selection = hou.selectedNodes()
    
    if selection:
        subnet = selection[0]
        bones = [n for n in subnet.children() if n.type().name() == 'bone']
        boneNameList = [b.name() for b in bones]
        bestGuess = [n.name() for n in subnet.glob('*LeftFoot* *RightFoot*') if n.type().name() == 'bone']
        selectedBones = [bones[i] for i in hou.ui.selectFromList(boneNameList, default_choices=[boneNameList.index(g) for g in bestGuess], message='Select 2 bones that serve as reference for the stride length', title='Bone Selection')]
        
        if len(selectedBones) != 2:
            hou.ui.displayMessage('Please select exactly 2 bones to analyze stride length ({} selected)'.format(len(selectedBones)), severity=hou.severityType.Error)
            return
        
        nulls = [n.inputConnections()[0].inputNode() for n in selectedBones]
        
        frameStart = int(hou.playbar.playbackRange()[0])
        frameEnd = int(hou.playbar.playbackRange()[1])
        frange = hou.ui.readMultiInput('Select the frame range to analyze the clip from', ['Start', 'End'], initial_contents=[str(frameStart), str(frameEnd)])
        
        # Range requires validation
        
        frameStart = int(frange[1][0])
        frameEnd = int(frange[1][1])
        
        minDist = sys.float_info.max
        minFrame = -1
        minLock = False
        minNoChange = 0
        
        maxDist = sys.float_info.min
        maxFrame = -1
        maxLock = False
        maxNoChange = 0
        
        # Choose axis to apply transformation
#        axes = ['X', 'Y', 'Z']
#        axis = axes[hou.ui.selectFromList(axes, default_choices=[0], message='Select axis to apply transformation along', title='Axis Selection')[0]].lower()
#        
#        hips = [n.inputConnections()[0].inputNode() for n in subnet.glob('*Hips*') if n.type().name() == 'bone'][0]
#        transform = hips.createInputNode(0, 'null', node_name='TRANSFORM')        
#        transformParm = transform.parm('t{}'.format(axis))
#        
#        subnet.layoutChildren()
        
        pastValue = 0.0
        pastDist = 0.0
        distThresh = 0.6
        
        for f in range(frameStart, frameEnd + 1):
            hou.setFrame(f)
            
            posArr = []
            keyframe = hou.Keyframe()
            
            keyframe.setFrame(f)
            
            for null in nulls:
                transformMatrix = null.worldTransform()
                potentialPointNodes = [n for n in null.children() if n.type().name() == 'add']
                
                if not potentialPointNodes:
                    hou.ui.displayMessage('Node {} didn\'t have expected Add node inside. Aborting.'.format(null.path()), severity=hou.severityType.Error)
                    return
                
                point = potentialPointNodes[0]
                pointPos = hou.Vector3([0.0, 0.0, 0.0])

                worldLocation = pointPos * transformMatrix
                
                posArr.append(worldLocation)
            
            dist = norm(array(posArr[0]) - array(posArr[1]))
            #dist = abs(posArr[0][2] - posArr[1][2])
            #dist = pastDist - posArr[1][2]
            deltaDist = abs(dist - pastDist)
            
            if deltaDist <= distThresh: # Lifoff from back foot, pull forward
                print 'Set pull forward key'
                keyframe = hou.Keyframe()
            
                keyframe.setFrame(f - 1)
                keyframe.setValue(pastValue)
                
                #transformParm.setKeyframe(keyframe)
                
                pastDist = dist
            
            if dist <= 2: # end of stride
                print 'set end key'
                keyframe = hou.Keyframe()
            
                keyframe.setFrame(f)
                keyframe.setValue(pastValue + abs(dist - pastDist))
                
                #transformParm.setKeyframe(keyframe)
                
                pastValue = pastValue + abs(dist - pastDist)
            
            print '{}\t-\t{}\t-\t{}'.format(f, dist, deltaDist)
            
            pastDist = dist
                        
            if dist > maxDist and not maxLock:
                maxDist = dist
                maxFrame = f
            else:
                maxNoChange += 1
                
                if maxNoChange >= FRAME_TIMEOUT:
                    maxLock = True
            
            if dist < minDist and not minLock:
                minDist = dist
                minFrame = f
            else:
                minNoChange += 1
                
                if minNoChange >= FRAME_TIMEOUT:
                    minLock = True
        
        strideLength = abs(maxDist - minDist)
        strideTime = abs(maxFrame - minFrame) + 1
        
        # DEBUG
        print '-'*30
        print 'Stride length / Stride time (frames):', strideLength, strideTime
        print 'Min distance @ frame:', minDist, minFrame
        print 'Max distance @ frame:', maxDist, maxFrame
        print '-'*30
        
        axes = ['X', 'Y', 'Z']
        axis = axes[hou.ui.selectFromList(axes, default_choices=[0], message='Select axis to apply transformation along', title='Axis Selection')[0]].lower()
        hips = [n.inputConnections()[0].inputNode() for n in subnet.glob('*Hips*') if n.type().name() == 'bone'][0]
        
        transform = hips.createInputNode(0, 'null', node_name='TRANSFORM')
        
        transform.parm('t{}'.format(axis)).setExpression('$F * {}'.format(strideLength / strideTime))
        
        subnet.layoutChildren()
    else:
        hou.ui.displayMessage('Please select a subnet where your FBX has been imported', severity=hou.severityType.Error)
        return
    
    
main()]]></script>
  </tool>

  <tool name="com.sashaouellet::convertrat::1.0" label="Convert to RAT" icon="hicon:/SVGIcons.index?SOP_filecache.svg">
    <helpText><![CDATA[= Convert to RAT =

"""Converts all referenced image files to RAT format, with the option to scale down and/or limit to a specific resolution."""

The default settings for this tool do not perform any scaling on the found images. First, Global Scale is calculated on all the images. Any images that still exceed the resolution set in "Max Resolution" will be further scaled down. By default, "None" means there is no max resolution. Choose "Custom" if you would like to specify a resolution other than the options provided.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os, sys
import imghdr
import subprocess
from PIL import Image

from PySide2.QtCore import *
from PySide2.QtGui import *
from PySide2.QtWidgets import *
from PySide2.QtUiTools import QUiLoader

ALTERNATE_IMAGE_EXTS = ['.hdr']

class OutputSettingsDialog(QDialog):
    def __init__(self):
        QDialog.__init__(self)
        
        toolbarDir = os.path.dirname(hou.shelves.runningTool().filePath())
        uiPath = os.path.join(toolbarDir, 'ui', 'convertRat.ui')
        
        file = QFile(uiPath)
        file.open(QFile.ReadOnly)
        
        loader = QUiLoader()
        self.ui = loader.load(file)
        
        self.ui.setStyleSheet(hou.qt.styleSheet())
        self.ui.LNE_maxRes.setValidator(QDoubleValidator())
        self.ui.LNE_maxRes.setEnabled(False)
        self.ui.CMB_maxRes.currentIndexChanged.connect(self.handleMaxResOption)
        
        self.ret = self.ui.exec_()
        
        hou.session.dummy = self.ui # Keeps the dialog open
    
    def handleMaxResOption(self, index):
        self.ui.LNE_maxRes.setEnabled(index == 6)
        
def main():
    hipDir = hou.getenv('HIP')
    
    dialog = OutputSettingsDialog()
    
    scaleOptions = [100.0, 75.0, 66.66, 50.0, 33.33, 25.0]
    maxResOptions = [-1, 4096.0, 2048.0, 1024.0, 512.0, 256.0, -2]
    
    if dialog.ret == QDialog.Rejected:
        return
        
    maxDim = maxResOptions[dialog.ui.CMB_maxRes.currentIndex()]
    scale = scaleOptions[dialog.ui.CMB_globalScale.currentIndex()]
    
    if maxDim == -2: # Custom dimension chosen, grab from line edit
        try:
            maxDim = float(dialog.ui.LNE_maxRes.text())
        except ValueError:
            hou.ui.displayMessage('Invalid input specified for max resolution (not a floating point number). Please try again.', title='Input Error', severity=hou.severityType.Error)
            return
        
    refs = hou.fileReferences()
    converted = 0
    
    with hou.InterruptableOperation('Converting images to RAT...') as operation:
        for parm, f in refs:            
            f = hou.expandString(f)
        
            if os.path.isfile(f) and os.path.exists(f) and isDescendant(f, hipDir) and isImage(f):
                newPath = convertImage(f, maxDim, scale)
                
                parm.set(getRelativeToHip(newPath))
                
                converted += 1
                
    hou.ui.displayMessage('Done converting {} image(s)'.format(converted), title='Conversion Complete')
                
def isImage(file):
    if imghdr.what(file) is not None:
        return True
    
    path, ext = os.path.splitext(file)
    
    if ext in ALTERNATE_IMAGE_EXTS:
        return True
    
    return False

def convertImage(file, maxDim, scale):
    args = [os.path.join(hou.getenv('HFS'), 'bin', 'icp')]
    scale /= 100.0
    resolution = hou.imageResolution(file)
    width = float(resolution[0]) * scale
    height = float(resolution[1]) * scale
    
    resizeFactor = 1.0
    
    if maxDim != -1: # Only calculate if user hasn't selected 'None'
        resizeFactor = float(maxDim) / width
        resizeFactor = min(resizeFactor, float(maxDim) / height) # if a smaller ratio, use that
    
    if resizeFactor < 1.0: # only want to scale down
        scale *= resizeFactor
         
    args.append('-u') # uncompressed, if supported
        
    args.append('-s')
    args.append(str(float(scale * 100)))

    newPath = '{}.rat'.format(os.path.splitext(file)[0])

    args.append(file)
    args.append(newPath)

    subprocess.call(args)
    
    return newPath
    
def isDescendant(file, root):
    return file.startswith(root)
    
def getRelativeToHip(file):
    hip = hou.getenv('HIP')
    
    return os.path.normpath(file.replace(hip, os.path.join('$HIP', '')))
    
main()]]></script>
  </tool>

  <shelfSetEdit name="shelf_set_td" fileLocation="C:/PROGRA~1/SIDEEF~1/HOUDIN~1.671/houdini/toolbar\ShelfDefinitions.shelf">
    <addMemberToolshelf name="com.sashaouellet::sdm_tools" inPosition="16"/>
  </shelfSetEdit>
</shelfDocument>
