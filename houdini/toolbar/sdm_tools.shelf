<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="com.sashaouellet::sdm_tools" label="SDM Tools">
    <memberTool name="com.sashaouellet::savprefstostuhome::1.0.0"/>
    <memberTool name="com.sashaouellet::multiflipbook::1.1.0"/>
    <memberTool name="com.sashaouellet::cleansubnet::1.0.0"/>
    <memberTool name="com.sashaouellet::calculatemocaplocomotion::1.0.0-alpha"/>
    <memberTool name="com.sashaouellet::convertrat::1.0.0"/>
  </toolshelf>

  <tool name="com.sashaouellet::savprefstostuhome::1.0.0" label="Save Prefs to Stuhome" icon="hicon:/SVGIcons.index?VOP_subnetconnector.svg">
    <helpText><![CDATA[= Save Prefs to Stuhome =

"""Saves desktops and other preferences on the network"""

This tool is meant to work alongside a bash_custom that copies your houdini16.0 folder from ~/mount/stuhome to ~/.

Example bash_custom:

rm -rf ~/houdini16.0

cp -r ~/mount/stuhome/houdini16.0 ~/houdini16.0

WARNING:
    Do not use this tool on Windows as it will crash Houdini. Your Houdini preferences are already synced on the network anyway on Windows.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os

def main():
    if not os.path.exists('~/mount/stuhome/houdini16.0'):
        return

    os.system('rm -rf ~/mount/stuhome/houdini16.0')
    os.system('cp -r ~/houdini16.0 ~/mount/stuhome/houdini16.0')

    hou.ui.displayMessage('Successfully copied preferences')

main()]]></script>
  </tool>

  <tool name="com.sashaouellet::multiflipbook::1.1.0" label="Multi Flipbook" icon="hicon:/SVGIcons.index?BUTTONS_capture.svg">
    <helpText><![CDATA[= Multi Flipbook =

"""Allows for flipbooking from multiple cameras simultaneously"""

Select all the cameras you want to flipbook from as well as the frame range and frame increment for the flipbook. Then select the file location to save to, making sure to include the $F syntax (or $F3, etc). The viewport will then be exported to these files with the camera name prefixed to the chosen file name.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os

def main():
    cameras = [c for c in hou.node('/').allSubChildren() if c.type().name() == 'cam']

    if not cameras:
        hou.ui.displayMessage('No cameras to flipbook from', title='No Cameras', severity=hou.severityType.Error)
        return

    selected = [cameras[i] for i in hou.ui.selectFromList([c.name() for c in cameras], message='Select the camera(s) to flipbook from', title='Camera Selection', column_header='Cameras')]

    if not selected:
        return

    outputBase = hou.ui.selectFile(title='Save Sequence(s) as...', collapse_sequences=True, file_type=hou.fileType.Image, chooser_mode=hou.fileChooserMode.Write)

    if not outputBase:
        return

    if '$F' not in outputBase:
        hou.ui.displayMessage('Invalid output path specified (Make sure to use $F, $F4, etc. notation)', severity=hou.severityType.Error)
        return

    splitBase = os.path.split(outputBase)
    sceneViewer = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)

    frameStart = int(sceneViewer.flipbookSettings().frameRange()[0])
    frameEnd = int(sceneViewer.flipbookSettings().frameRange()[1])
    frameInc = sceneViewer.flipbookSettings().frameIncrement()

    frameInput = hou.ui.readMultiInput('Select frame range for flipbook(s)', ['Start', 'End', 'Inc'], initial_contents=[str(frameStart), str(frameEnd), str(frameInc)])

    frameStart = int(frameInput[1][0])
    frameEnd = int(frameInput[1][1])
    frameInc = int(frameInput[1][2])

    if not sceneViewer:
        hou.ui.displayMessage('Could not find Scene Viewer pane tab, please create it and try again', severity=hou.severityType.Error)
        raise SystemExit

    viewport = [vp for vp in sceneViewer.viewports() if vp.type() == hou.geometryViewportType.Perspective][0]

    if not viewport:
        hou.ui.displayMessage('Could not find the "Persp" viewport', severity=hou.severityType.Error)
        raise SystemExit

    viewportFullName = '{}.{}.world.{}'.format(hou.ui.curDesktop().name(), sceneViewer.name(), viewport.name())
    cameraOutputs = []

    for camera in selected:
        cameraOutputs.append((camera, os.path.join(splitBase[0], '{}_{}'.format(camera.name(), splitBase[1]))))

    for f in range(frameStart, frameEnd + 1, frameInc):
        for camera, output in cameraOutputs:
            hou.setFrame(f)
            viewport.setCamera(camera)

            hou.hscript("viewwrite -f {} {} {} '{}'".format(f, f, viewportFullName, output))

main()]]></script>
  </tool>

  <tool name="com.sashaouellet::cleansubnet::1.0.0" label="Clean Subnet" icon="hicon:/SVGIcons.index?BUTTONS_clear.svg">
    <helpText><![CDATA[= Clean Subnet =

"""Removes the entire tree structure from selected nodes of a subnet"""

This is a convienence tool for cleaning up large FBX's. Note that the selection is the node trees you want to delete.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[def main():
    selected = hou.selectedNodes()

    if selected and len(selected) == 1:
        subnet = selected[0] # Selected subnet
        topLevel = [c for c in subnet.children() if not c.inputConnections()] # All nodes inside the subnet with no incoming connections are assumed to be top level parents
        potentialDelete = ['System', 'Unlabeled_Markers'] # Node names for nodes that we probably will always delete
        bestGuesses = [topLevel.index(n) for n in topLevel if n.name() in potentialDelete] # We guess from the children nodes based on potentialDelete

        # bestGuesses is passed as the default choices, which will highlight them automatically and queue for deletion
        # We clear this selection on cancel, so that they don't accidentally delete anything
        toDelete = [topLevel[i] for i in hou.ui.selectFromList([n.name() for n in topLevel], default_choices=bestGuesses, message='Select top level parents that you want to DELETE', title='Delete Trees')]

        if toDelete and hou.ui.displayConfirmation('You are about to delete: {} and all of the connections to these nodes. Are you sure you want to proceed?'.format(', '.join([n.name() for n in toDelete]))):
            for node in toDelete:
                deleteTree(node)

        subnet.layoutChildren()
    else:
        hou.ui.displayMessage('Please select a single node for cleanup', severity=hou.severityType.Error)
        return


def deleteTree(node):
    if not node.isLockedHDA() and not node.isInsideLockedHDA():
        for connected in [n.outputNode() for n in node.outputConnections()]:
            deleteTree(connected) # Recursively delete output connections
        node.destroy()
main()]]></script>
  </tool>

  <tool name="com.sashaouellet::calculatemocaplocomotion::1.0.0-alpha" label="Calculate Mocap Locomotion" icon="hicon:/SVGIcons.index?OBJ_simplemale.svg">
    <helpText><![CDATA[= Calculate Mocap Locomotion =

"""Applies physical transforms to mocap rig based on stride length/speed."""

This tool will automatically calculate a stride length from the frame range that is selected and the 2 bones selected. It is recommended you choose the feet bones, and the tool will automatically pick those for you to begin with. The transform is applied to the root of the mocap rig.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import sys, math
from numpy.linalg import norm
from numpy import array

FRAME_TIMEOUT = 5

def main():
    selection = hou.selectedNodes()

    if selection:
        subnet = selection[0]
        bones = [n for n in subnet.children() if n.type().name() == 'bone']
        boneNameList = [b.name() for b in bones]
        bestGuess = [n.name() for n in subnet.glob('*LeftFoot* *RightFoot*') if n.type().name() == 'bone']
        selectedBones = [bones[i] for i in hou.ui.selectFromList(boneNameList, default_choices=[boneNameList.index(g) for g in bestGuess], message='Select 2 bones that serve as reference for the stride length', title='Bone Selection')]

        if len(selectedBones) != 2:
            hou.ui.displayMessage('Please select exactly 2 bones to analyze stride length ({} selected)'.format(len(selectedBones)), severity=hou.severityType.Error)
            return

        nulls = [n.inputConnections()[0].inputNode() for n in selectedBones]

        frameStart = int(hou.playbar.playbackRange()[0])
        frameEnd = int(hou.playbar.playbackRange()[1])
        frange = hou.ui.readMultiInput('Select the frame range to analyze the clip from', ['Start', 'End'], initial_contents=[str(frameStart), str(frameEnd)])

        # Range requires validation

        frameStart = int(frange[1][0])
        frameEnd = int(frange[1][1])

        minDist = sys.float_info.max
        minFrame = -1
        minLock = False
        minNoChange = 0

        maxDist = sys.float_info.min
        maxFrame = -1
        maxLock = False
        maxNoChange = 0

        # Choose axis to apply transformation
#        axes = ['X', 'Y', 'Z']
#        axis = axes[hou.ui.selectFromList(axes, default_choices=[0], message='Select axis to apply transformation along', title='Axis Selection')[0]].lower()
#
#        hips = [n.inputConnections()[0].inputNode() for n in subnet.glob('*Hips*') if n.type().name() == 'bone'][0]
#        transform = hips.createInputNode(0, 'null', node_name='TRANSFORM')
#        transformParm = transform.parm('t{}'.format(axis))
#
#        subnet.layoutChildren()

        pastValue = 0.0
        pastDist = 0.0
        distThresh = 0.6

        for f in range(frameStart, frameEnd + 1):
            hou.setFrame(f)

            posArr = []
            keyframe = hou.Keyframe()

            keyframe.setFrame(f)

            for null in nulls:
                transformMatrix = null.worldTransform()
                potentialPointNodes = [n for n in null.children() if n.type().name() == 'add']

                if not potentialPointNodes:
                    hou.ui.displayMessage('Node {} didn\'t have expected Add node inside. Aborting.'.format(null.path()), severity=hou.severityType.Error)
                    return

                point = potentialPointNodes[0]
                pointPos = hou.Vector3([0.0, 0.0, 0.0])

                worldLocation = pointPos * transformMatrix

                posArr.append(worldLocation)

            dist = norm(array(posArr[0]) - array(posArr[1]))
            #dist = abs(posArr[0][2] - posArr[1][2])
            #dist = pastDist - posArr[1][2]
            deltaDist = abs(dist - pastDist)

            if deltaDist <= distThresh: # Lifoff from back foot, pull forward
                print 'Set pull forward key'
                keyframe = hou.Keyframe()

                keyframe.setFrame(f - 1)
                keyframe.setValue(pastValue)

                #transformParm.setKeyframe(keyframe)

                pastDist = dist

            if dist <= 2: # end of stride
                print 'set end key'
                keyframe = hou.Keyframe()

                keyframe.setFrame(f)
                keyframe.setValue(pastValue + abs(dist - pastDist))

                #transformParm.setKeyframe(keyframe)

                pastValue = pastValue + abs(dist - pastDist)

            print '{}\t-\t{}\t-\t{}'.format(f, dist, deltaDist)

            pastDist = dist

            if dist > maxDist and not maxLock:
                maxDist = dist
                maxFrame = f
            else:
                maxNoChange += 1

                if maxNoChange >= FRAME_TIMEOUT:
                    maxLock = True

            if dist < minDist and not minLock:
                minDist = dist
                minFrame = f
            else:
                minNoChange += 1

                if minNoChange >= FRAME_TIMEOUT:
                    minLock = True

        strideLength = abs(maxDist - minDist)
        strideTime = abs(maxFrame - minFrame) + 1

        # DEBUG
        print '-'*30
        print 'Stride length / Stride time (frames):', strideLength, strideTime
        print 'Min distance @ frame:', minDist, minFrame
        print 'Max distance @ frame:', maxDist, maxFrame
        print '-'*30

        axes = ['X', 'Y', 'Z']
        axis = axes[hou.ui.selectFromList(axes, default_choices=[0], message='Select axis to apply transformation along', title='Axis Selection')[0]].lower()
        hips = [n.inputConnections()[0].inputNode() for n in subnet.glob('*Hips*') if n.type().name() == 'bone'][0]

        transform = hips.createInputNode(0, 'null', node_name='TRANSFORM')

        transform.parm('t{}'.format(axis)).setExpression('$F * {}'.format(strideLength / strideTime))

        subnet.layoutChildren()
    else:
        hou.ui.displayMessage('Please select a subnet where your FBX has been imported', severity=hou.severityType.Error)
        return


main()]]></script>
  </tool>

  <tool name="com.sashaouellet::convertrat::1.0.0" label="Convert to RAT" icon="SHELF_ConvertToRAT">
    <helpText><![CDATA[= Convert to RAT =

"""Converts all referenced image files to RAT format, with the option to scale down and/or limit to a specific resolution."""

The default settings for this tool do not perform any scaling on the found images. First, Global Scale is calculated on all the images. Any images that still exceed the resolution set in "Max Resolution" will be further scaled down. By default, "None" means there is no max resolution. Choose "Custom" if you would like to specify a resolution other than the options provided.

Created by [Sasha Ouellet|http://www.sashaouellet.com]]]></helpText>
    <script scriptType="python"><![CDATA[import os
import sdmtools
from sdmtools.image import convertImageToRAT, isImage
from sdmtools.fileutils import isDescendant, getRelativeToHip, getAllFileReferences

from PySide2.QtCore import *
from PySide2.QtGui import *
from PySide2.QtWidgets import *
from PySide2.QtUiTools import QUiLoader

class OutputSettingsDialog(QDialog):
    def __init__(self):
        QDialog.__init__(self)

        uiPath = os.path.join(sdmtools.folder, 'ui', 'SHELF_convertRat.ui')

        file = QFile(uiPath)
        file.open(QFile.ReadOnly)

        loader = QUiLoader()
        self.ui = loader.load(file)

        self.ui.setStyleSheet(hou.qt.styleSheet())
        self.ui.LNE_maxRes.setValidator(QDoubleValidator())
        self.ui.LNE_maxRes.setEnabled(False)
        self.ui.CMB_maxRes.currentIndexChanged.connect(self.handleMaxResOption)

        self.ret = self.ui.exec_()

        hou.session.dummy = self.ui # Keeps the dialog open

    def handleMaxResOption(self, index):
        self.ui.LNE_maxRes.setEnabled(index == 6)

def main():
    dialog = OutputSettingsDialog()

    scaleOptions = [100.0, 75.0, 66.66, 50.0, 33.33, 25.0]
    maxResOptions = [-1, 4096.0, 2048.0, 1024.0, 512.0, 256.0, -2]

    if dialog.ret == QDialog.Rejected:
        return

    maxDim = maxResOptions[dialog.ui.CMB_maxRes.currentIndex()]
    scale = scaleOptions[dialog.ui.CMB_globalScale.currentIndex()]

    if maxDim == -2: # Custom dimension chosen, grab from line edit
        try:
            maxDim = float(dialog.ui.LNE_maxRes.text())
        except ValueError:
            hou.ui.displayMessage('Invalid input specified for max resolution (not a floating point number). Please try again.', title='Input Error', severity=hou.severityType.Error)
            return

    refs = hou.fileReferences()
    conversions = {}

    with hou.InterruptableOperation('Converting images to RAT...') as operation:
        for _, f in refs:
            f = hou.expandString(f)

            if os.path.isfile(f) and os.path.exists(f) and isDescendant(f) and isImage(f):
                newPath = convertImageToRAT(f, maxDim, scale)                
                conversions[f] = getRelativeToHip(newPath)
    
    allRefs = getAllFileReferences()
    
    for parm, ref in allRefs:
        newPath = conversions.get(ref)
        
        if newPath:
            parm.set(newPath)

    hou.ui.displayMessage('Done converting {} image(s)'.format(len(conversions)), title='Conversion Complete')
    
main()]]></script>
  </tool>

  <shelfSetEdit name="shelf_set_td" fileLocation="C:/PROGRA~1/SIDEEF~1/HOUDIN~1.671/houdini/toolbar\ShelfDefinitions.shelf">
    <addMemberToolshelf name="com.sashaouellet::sdm_tools" inPosition="16"/>
  </shelfSetEdit>
</shelfDocument>
